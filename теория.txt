В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
typeof null // "object"– это официально признанная ошибка в языке

undefined «значение не присвоено»
Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined

Операнд – то, к чему применяется оператор.Другое название: «аргумент оператора»

Унарным называется оператор, который применяется к одному выражению.

Бинарным называется оператор, который применяется к двум операндам. 

Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
Это приведение к строке – особенность исключительно бинарного оператора "+".
Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

Инкремент ++ увеличивает на 1
Декремент -- уменьшает на 1

i++ (называется «постфиксная форма») или ++i («префиксная форма»).

Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.
Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую форму использовать
Если хочется тут же использовать результат, то нужна префиксная форма

var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)

alert( 0 == false ); // true
alert( '' == false ); // true

Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
При преобразовании в число null становится 0, а undefined становится NaN.
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true

Значение undefined вообще нельзя сравнивать

Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.

confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.

Результатом будет true при нажатии OK и false – при CANCEL(Esc)

В логическом контексте:
Число 0, пустая строка "", null и undefined, а также NaN являются false,
Остальные значения – true.

|| запинается на «правде»,
&& запинается на «лжи».

Численное преобразование:
undefined	NaN
null	0
true / false	1 / 0
Строка	Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

Function Declaration – функция, объявленная в основном потоке кода.
Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.
Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.


Function                         Declaration	                  Function Expression
Время создания	    До выполнения первой строчки кода.         	Когда управление достигает строки с функцией.
Можно вызвать до объявления	Да (т.к. создаётся заранее)	          Нет
Условное объявление в if	Не работает	                        Работает

В теле функции могут быть вызываны другие функции для выполнения подзадач.
Частный случай подвызова – когда функция вызывает сама себя. Это называется рекурсией.
Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.

Watch Expressions – показывает текущие значения любых выражений.

Можно раскрыть эту вкладку, нажать мышью + на ней и ввести любое выражение. Отладчик будет отображать его значение на текущий момент, автоматически перевычисляя его при проходе по коду.

Call Stack – стек вызовов, все вложенные вызовы, которые привели к текущему месту кода.
На текущий момент видно, отладчик находится в функции pow (pow.js, строка 6), вызванной из анонимного кода (index.html, строка 13).
Scope Variables – переменные.
На текущий момент строка 6 ещё не выполнилась, поэтому result равен undefined.
В Local показываются переменные функции: объявленные через var и параметры. Вы также можете там видеть ключевое слово this, если вы не знаете, что это такое – ничего страшного, мы это обсудим позже, в следующих главах учебника.
В Global – глобальные переменные и функции.

BDD – поведенческие тесты кода Behavior Driven Development. Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.

Вот самые востребованные assert-проверки, встроенные в Chai:

assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false
…более полный список – в документации http://chaijs.com/api/assert/

___________________________________________________Числа________________________________________________

свойство length, содержащее длину
Также у строк есть метод toUpperCase(), который возвращает строку в верхнем регистре
Метод – это встроенная команда («функция», мы поговорим о них позже), которую нужно вызвать для получения значения.
Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки

Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity

Infinity больше любого числа.
Добавление к бесконечности не меняет её.

Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробноe

Метод toString() возвращает строку, представляющую объект.

Math.floor Округляет вниз

Math.ceil Округляет вверх

Math.round Округляет до ближайшего целого

Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки

Встроенные функции для тригонометрических вычислений:

Math.acos(x)
Возвращает арккосинус x (в радианах)
Math.asin(x)
Возвращает арксинус x (в радианах)
Math.atan(x)
Возвращает арктангенс x (в радианах)
Math.atan2(y, x)
Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)
Вычисляет синус x
Math.cos(x)
Вычисляет косинус x
Math.tan(x)
Возвращает тангенс x
Функции общего назначения

Разные полезные функции:

Math.sqrt(x)
Возвращает квадратный корень из x.
Math.log(x)
Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)
Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)
Возвращает абсолютное значение числа
Math.exp(x)
Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...)
Возвращает наибольший из списка аргументов
Math.min(a, b, c...)
Возвращает наименьший из списка аргументов
Math.random()
Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.
Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString()

_________________________________________________Строки_________________________________________________

Строки могут содержать специальные символы. Самый часто используемый из таких символов – это «перевод строки». Он обозначается как \n
alert( 'Привет\nМир' ); // выведет "Мир" на новой строке
Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \'
var str = 'I\'m a JavaScript programmer';

Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0
var str = "jQuery";
alert( str.charAt(0) ); // "j"
var str = "Я - современный браузер!";
alert( str[0] ); // "Я"
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined

Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний

Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено.
var str = "Widget with id";
alert( str.indexOf("id") ); // 1
Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки.

Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.Если аргумент end отсутствует, то идет до конца строки
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:

substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов. Если второго аргумента нет – подразумевается «до конца строки».

slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.
Отрицательные значения отсчитываются от конца строки:
Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами

String.fromCharCode(code)
Возвращает символ по коду code: alert( String.fromCharCode(1072) ); // 'а'

str.charCodeAt(pos)
Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля. alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'

Кстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» (numeric character reference).
Для этого нужно написать сначала &#, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;.
Если код хотят дать в 16-ричной системе счисления, то начинают с &#x.
В юникоде есть много забавных и полезных символов, например, символ ножниц: ? (&#x2702;), дроби: ? (&#xBD;) ? (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.

Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:
alert( "2" > "14" ); // true
alert( 2 > "14" ); // false

Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны

_______________________________________Объекты как ассоциативные массивы________________________________

Объекты в JavaScript сочетают в себе два важных функционала.
Первый – это ассоциативный массив: структура, пригодная для хранения любых данных. В этой главе мы рассмотрим использование объектов именно как массивов.
Второй – языковые возможности для объектно-ориентированного программирования. Эти возможности мы изучим в последующих разделах учебника.
Ассоциативный массив – структура данных, в которой можно хранить любые данные в формате ключ-значение.
Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства (иногда говорят «по ключу»).

Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.
Для этого есть особый оператор: "in".
Его синтаксис: "prop" in obj, причем имя свойства – в виде строки
if ("name" in person) {
  alert( "Свойство name существует!" );
}
Впрочем, чаще используется другой способ – сравнение значения с undefined.
Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет.
Дело в том, что технически возможно, что свойство есть, а его значением является undefined

Как правило, в коде мы не будем присваивать undefined, чтобы корректно работали обе проверки. А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать null.

var person = {};
person.name = 'Вася';
person.age = 25;
delete person.name;
console.log(person.name);

Доступ через квадратные скобки
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:
person['OS'] = 'Ubuntu';

Доступ к свойству через переменную
var person = {};
person.age = 25;
var key = 'age';
alert( person[key] ); // выведет person['age']
Вообще, если имя свойства хранится в переменной (var key = "age"), то единственный способ к нему обратиться – это квадратные скобки person[key].

Объект — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Значением свойства может быть функция, которую можно назвать методом объекта

Такой синтаксис называется литеральным
var menuSetup = {
  width: 300,
  height: 200,
  title: "Menu"
};

____________________________________________Объекты: перебор свойств____________________________________
Для перебора всех свойств из объекта используется цикл по свойствам for..in. Эта синтаксическая конструкция 
var obj = {
  menu: 'Cesar',
  time: '18.00',
  day: 'monday'
};

for (dec in obj) {
    console.log(dec + ':' + obj[dec]);
}

Соглашение говорит, что если имя свойства – нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались.
Можно применить небольшой хак, который заключается в том, чтобы сделать все ключи нечисловыми, например, добавим в начало дополнительный символ '+'

_________________________________________Объекты: передача по ссылке____________________________________
В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.
Внимание: объект – вне переменной. В переменной – лишь «адрес» (ссылка) для него.
При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.
var user = { name: "Вася" }; // в переменной - ссылка
var admin = user; // скопировали ссылку
Получили две переменные, в которых находятся ссылки на один и тот же объект

Переменная с объектом как «ключ» к сейфу с данными
Ещё одна аналогия: переменная, в которую присвоен объект, на самом деле хранит не сами данные, а ключ к сейфу, где они хранятся.
При копировании её, получается что мы сделали копию ключа, но сейф по-прежнему один.

Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.
Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов.
var user = {
  name: "Вася",
  age: 30
};
var clone = {}; // новый пустой объект
// скопируем в него все свойства user
for (var key in user) {
  clone[key] = user[key];
}
// теперь clone - полностью независимая копия
clone.name = "Петя"; // поменяли данные в clone
alert( user.name ); // по-прежнему "Вася"

Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью.

____________________________________Массивы с числовыми индексами_______________________________________
Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.
Элементы нумеруются, начиная с нуля.
var fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits[0] ); // Яблоко
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
Или добавить:
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
Общее число элементов, хранимых в массиве, содержится в его свойстве length
В массиве может храниться любое число элементов любого типа.
В том числе, строки, числа, объекты, вот например:
 // микс значений
var arr = [ 1, 'Имя', { name: 'Петя' }, true ];
// получить объект из массива и тут же -- его свойство
alert( arr[2].name ); // Петя

pop Удаляет последний элемент из массива и возвращает его fruits.pop()

push Добавляет элемент в конец массива fruits.push("Груша"); или так arr[arr.length] = 'xnjsdfs'; /могут добавлять сразу по несколько элементов

shift Удаляет из массива первый элемент и возвращает его fruits.shift()

unshift Добавляет элемент в начало массива /могут добавлять сразу по несколько элементов

Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.

Ещё одно следствие – можно присваивать в массив любые свойства.
var fruits = []; // создать массив
fruits[99999] = 5; // присвоить свойство с любым номером
fruits.age = 25; // назначить свойство со строковым именем

Если в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются «лишние» запятые

Если коротко: цикл for(var i=0; i<arr.length...) надёжнее и быстрее. чем цикл for..in 

Длина length – не количество элементов массива, а последний индекс + 1 Так уж оно устроено.
var arr = [];
arr[1000] = true;
alert(arr.length); // 1001

При уменьшении length массив укорачивается
Причем этот процесс необратимый, т.е. даже если потом вернуть length обратно – значения не восстановятся:
var arr = [1, 2, 3, 4, 5];
arr.length = 2; // укоротить до 2 элементов
alert( arr ); // [1, 2]
arr.length = 5; // вернуть length обратно, как было
alert( arr[3] ); // undefined: значения не вернулись
Самый простой способ очистить массив – это arr.length=0.

Существует еще один синтаксис для создания массива:
var arr = new Array("Яблоко", "Груша", "и т.п.");
Он редко используется, т.к. квадратные скобки [] короче.
Кроме того, у него есть одна особенность. Обычно new Array(элементы, ...) создаёт массив из данных элементов, но если у него один аргумент-число new Array(число), то он создает массив без элементов, но с заданной длиной.
var arr = new Array(2, 3);
alert( arr[0] ); // 2, создан массив [2, 3], всё ок
arr = new Array(2); // создаст массив [2] ?
alert( arr[0] ); // undefined! у нас массив без элементов, длины 2

Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:
 var matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
alert( matrix[1][1] ); // центральный элемент
























