В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
typeof null // "object"– это официально признанная ошибка в языке

undefined «значение не присвоено»
Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined

Операнд – то, к чему применяется оператор.Другое название: «аргумент оператора»

Унарным называется оператор, который применяется к одному выражению.

Бинарным называется оператор, который применяется к двум операндам. 

Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
Это приведение к строке – особенность исключительно бинарного оператора "+".
Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

Инкремент ++ увеличивает на 1
Декремент -- уменьшает на 1

i++ (называется «постфиксная форма») или ++i («префиксная форма»).

Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.
Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую форму использовать
Если хочется тут же использовать результат, то нужна префиксная форма

var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)

alert( 0 == false ); // true
alert( '' == false ); // true

Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
При преобразовании в число null становится 0, а undefined становится NaN.
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true

Значение undefined вообще нельзя сравнивать

Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.

confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.

Результатом будет true при нажатии OK и false – при CANCEL(Esc)

В логическом контексте:
Число 0, пустая строка "", null и undefined, а также NaN являются false,
Остальные значения – true.

|| запинается на «правде»,
&& запинается на «лжи».

Численное преобразование:
undefined	NaN
null	0
true / false	1 / 0
Строка	Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

Function Declaration – функция, объявленная в основном потоке кода.
Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.
Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.


Function                         Declaration	                  Function Expression
Время создания	    До выполнения первой строчки кода.         	Когда управление достигает строки с функцией.
Можно вызвать до объявления	Да (т.к. создаётся заранее)	          Нет
Условное объявление в if	Не работает	                        Работает

В теле функции могут быть вызываны другие функции для выполнения подзадач.
Частный случай подвызова – когда функция вызывает сама себя. Это называется рекурсией.
Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.

Watch Expressions – показывает текущие значения любых выражений.

Можно раскрыть эту вкладку, нажать мышью + на ней и ввести любое выражение. Отладчик будет отображать его значение на текущий момент, автоматически перевычисляя его при проходе по коду.

Call Stack – стек вызовов, все вложенные вызовы, которые привели к текущему месту кода.
На текущий момент видно, отладчик находится в функции pow (pow.js, строка 6), вызванной из анонимного кода (index.html, строка 13).
Scope Variables – переменные.
На текущий момент строка 6 ещё не выполнилась, поэтому result равен undefined.
В Local показываются переменные функции: объявленные через var и параметры. Вы также можете там видеть ключевое слово this, если вы не знаете, что это такое – ничего страшного, мы это обсудим позже, в следующих главах учебника.
В Global – глобальные переменные и функции.

BDD – поведенческие тесты кода Behavior Driven Development. Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.

Вот самые востребованные assert-проверки, встроенные в Chai:

assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false
…более полный список – в документации http://chaijs.com/api/assert/

___________________________________________________Числа________________________________________________

свойство length, содержащее длину
Также у строк есть метод toUpperCase(), который возвращает строку в верхнем регистре
Метод – это встроенная команда («функция», мы поговорим о них позже), которую нужно вызвать для получения значения.
Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки

Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity

Infinity больше любого числа.
Добавление к бесконечности не меняет её.

Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.
При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробноe

Метод toString() возвращает строку, представляющую объект.

Math.floor Округляет вниз

Math.ceil Округляет вверх

Math.round Округляет до ближайшего целого

Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки

Встроенные функции для тригонометрических вычислений:

Math.acos(x)
Возвращает арккосинус x (в радианах)
Math.asin(x)
Возвращает арксинус x (в радианах)
Math.atan(x)
Возвращает арктангенс x (в радианах)
Math.atan2(y, x)
Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)
Вычисляет синус x
Math.cos(x)
Вычисляет косинус x
Math.tan(x)
Возвращает тангенс x
Функции общего назначения

Разные полезные функции:

Math.sqrt(x)
Возвращает квадратный корень из x.
Math.log(x)
Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)
Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)
Возвращает абсолютное значение числа
Math.exp(x)
Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...)
Возвращает наибольший из списка аргументов
Math.min(a, b, c...)
Возвращает наименьший из списка аргументов
Math.random()
Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.
Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString()

_________________________________________________Строки_________________________________________________

Строки могут содержать специальные символы. Самый часто используемый из таких символов – это «перевод строки». Он обозначается как \n
alert( 'Привет\nМир' ); // выведет "Мир" на новой строке
Если строка в одинарных кавычках, то внутренние одинарные кавычки внутри должны быть экранированы, то есть снабжены обратным слешем \'
var str = 'I\'m a JavaScript programmer';

Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0
var str = "jQuery";
alert( str.charAt(0) ); // "j"
var str = "Я - современный браузер!";
alert( str[0] ); // "Я"
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined

Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний

Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).
Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено.
var str = "Widget with id";
alert( str.indexOf("id") ); // 1
Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки.

Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end.Если аргумент end отсутствует, то идет до конца строки
Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:
Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:

substr(start [, length])
Первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов. Если второго аргумента нет – подразумевается «до конца строки».

slice(start [, end])
Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.
Отрицательные значения отсчитываются от конца строки:
Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами

String.fromCharCode(code)
Возвращает символ по коду code: alert( String.fromCharCode(1072) ); // 'а'

str.charCodeAt(pos)
Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля. alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'

Кстати, если мы знаем код символа в кодировке юникод, то можем добавить его в HTML, используя «числовую ссылку» (numeric character reference).
Для этого нужно написать сначала &#, затем код, и завершить точкой с запятой ';'. Например, символ 'а' в виде числовой ссылки: &#1072;.
Если код хотят дать в 16-ричной системе счисления, то начинают с &#x.
В юникоде есть много забавных и полезных символов, например, символ ножниц: ? (&#x2702;), дроби: ? (&#xBD;) ? (&#xBE;) и другие. Их можно использовать вместо картинок в дизайне.

Если хотя бы один аргумент – не строка, то другой будет преобразован к числу:
alert( "2" > "14" ); // true
alert( 2 > "14" ); // false

Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2 и 0, если они равны

_______________________________________Объекты как ассоциативные массивы________________________________

Объекты в JavaScript сочетают в себе два важных функционала.
Первый – это ассоциативный массив: структура, пригодная для хранения любых данных. В этой главе мы рассмотрим использование объектов именно как массивов.
Второй – языковые возможности для объектно-ориентированного программирования. Эти возможности мы изучим в последующих разделах учебника.
Ассоциативный массив – структура данных, в которой можно хранить любые данные в формате ключ-значение.
Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства (иногда говорят «по ключу»).

Иногда бывает нужно проверить, есть ли в объекте свойство с определенным ключом.
Для этого есть особый оператор: "in".
Его синтаксис: "prop" in obj, причем имя свойства – в виде строки
if ("name" in person) {
  alert( "Свойство name существует!" );
}
Впрочем, чаще используется другой способ – сравнение значения с undefined.
Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет.
Дело в том, что технически возможно, что свойство есть, а его значением является undefined

Как правило, в коде мы не будем присваивать undefined, чтобы корректно работали обе проверки. А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать null.

var person = {};
person.name = 'Вася';
person.age = 25;
delete person.name;
console.log(person.name);

Доступ через квадратные скобки
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:
person['OS'] = 'Ubuntu';

Доступ к свойству через переменную
var person = {};
person.age = 25;
var key = 'age';
alert( person[key] ); // выведет person['age']
Вообще, если имя свойства хранится в переменной (var key = "age"), то единственный способ к нему обратиться – это квадратные скобки person[key].

Объект — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Значением свойства может быть функция, которую можно назвать методом объекта

Такой синтаксис называется литеральным
var menuSetup = {
  width: 300,
  height: 200,
  title: "Menu"
};

____________________________________________Объекты: перебор свойств____________________________________
Для перебора всех свойств из объекта используется цикл по свойствам for..in. Эта синтаксическая конструкция 
var obj = {
  menu: 'Cesar',
  time: '18.00',
  day: 'monday'
};

for (dec in obj) {
    console.log(dec + ':' + obj[dec]);
}

Соглашение говорит, что если имя свойства – нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались.
Можно применить небольшой хак, который заключается в том, чтобы сделать все ключи нечисловыми, например, добавим в начало дополнительный символ '+'

_________________________________________Объекты: передача по ссылке____________________________________
В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.
Внимание: объект – вне переменной. В переменной – лишь «адрес» (ссылка) для него.
При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.
var user = { name: "Вася" }; // в переменной - ссылка
var admin = user; // скопировали ссылку
Получили две переменные, в которых находятся ссылки на один и тот же объект

Переменная с объектом как «ключ» к сейфу с данными
Ещё одна аналогия: переменная, в которую присвоен объект, на самом деле хранит не сами данные, а ключ к сейфу, где они хранятся.
При копировании её, получается что мы сделали копию ключа, но сейф по-прежнему один.

Иногда, на практике – очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, «клон» объекта.
Что ж, можно сделать и это. Для этого нужно пройти по объекту, достать данные и скопировать на уровне примитивов.
var user = {
  name: "Вася",
  age: 30
};
var clone = {}; // новый пустой объект
// скопируем в него все свойства user
for (var key in user) {
  clone[key] = user[key];
}
// теперь clone - полностью независимая копия
clone.name = "Петя"; // поменяли данные в clone
alert( user.name ); // по-прежнему "Вася"

Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он находится.
Если переменная-объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть полностью.

____________________________________Массивы с числовыми индексами_______________________________________
Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.
Элементы нумеруются, начиная с нуля.
var fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits[0] ); // Яблоко
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
Или добавить:
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]
Общее число элементов, хранимых в массиве, содержится в его свойстве length
В массиве может храниться любое число элементов любого типа.
В том числе, строки, числа, объекты, вот например:
 // микс значений
var arr = [ 1, 'Имя', { name: 'Петя' }, true ];
// получить объект из массива и тут же -- его свойство
alert( arr[2].name ); // Петя

pop Удаляет последний элемент из массива и возвращает его fruits.pop()

push Добавляет элемент в конец массива fruits.push("Груша"); или так arr[arr.length] = 'xnjsdfs'; /могут добавлять сразу по несколько элементов

shift Удаляет из массива первый элемент и возвращает его fruits.shift()

unshift Добавляет элемент в начало массива /могут добавлять сразу по несколько элементов

Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.

Ещё одно следствие – можно присваивать в массив любые свойства.
var fruits = []; // создать массив
fruits[99999] = 5; // присвоить свойство с любым номером
fruits.age = 25; // назначить свойство со строковым именем

Если в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются «лишние» запятые

Если коротко: цикл for(var i=0; i<arr.length...) надёжнее и быстрее. чем цикл for..in 

Длина length – не количество элементов массива, а последний индекс + 1 Так уж оно устроено.
var arr = [];
arr[1000] = true;
alert(arr.length); // 1001

При уменьшении length массив укорачивается
Причем этот процесс необратимый, т.е. даже если потом вернуть length обратно – значения не восстановятся:
var arr = [1, 2, 3, 4, 5];
arr.length = 2; // укоротить до 2 элементов
alert( arr ); // [1, 2]
arr.length = 5; // вернуть length обратно, как было
alert( arr[3] ); // undefined: значения не вернулись
Самый простой способ очистить массив – это arr.length=0.

Существует еще один синтаксис для создания массива:
var arr = new Array("Яблоко", "Груша", "и т.п.");
Он редко используется, т.к. квадратные скобки [] короче.
Кроме того, у него есть одна особенность. Обычно new Array(элементы, ...) создаёт массив из данных элементов, но если у него один аргумент-число new Array(число), то он создает массив без элементов, но с заданной длиной.
var arr = new Array(2, 3);
alert( arr[0] ); // 2, создан массив [2, 3], всё ок
arr = new Array(2); // создаст массив [2] ?
alert( arr[0] ); // undefined! у нас массив без элементов, длины 2

Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:
 var matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
alert( matrix[1][1] ); // центральный элемент

_______________________________________________Массивы: методы__________________________________________
метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю s. В примере ниже таким разделителем является строка из запятой и пробела.
var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', ');
for (var i = 0; i < arr.length; i++) {
  alert( 'Вам сообщение ' + arr[i] );
}
У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен

arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.
var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');
alert( str ); // Маша;Петя;Марина;Василий

Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete
delete arr[1]; // значение с индексом 1 удалено
элемент удален из массива, но не так, как нам этого хочется. Образовалась «дырка».
оператор delete удаляет пару «ключ-значение». Это – все, что он делает. 

Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.
arr.splice(index[, deleteCount, elem1, ..., elemN])

arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент

// удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем")

// удалить 2 первых элемента
var removed = arr.splice(0, 2);
alert( removed ); // "Я", "сейчас" <-- Здесь видно, что splice возвращает массив из удаленных элементов

Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0: arr.splice(2, 0, "сложный", "язык");

Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
alert( arr2 ); // надо, учить
Если не указать end – копирование будет до конца массива
Можно использовать отрицательные индексы, они отсчитываются с конца
Если вообще не указать аргументов – скопируется весь массив

Метод sort() сортирует массив на месте.
var arr = [ 1, 2, 15 ];
arr.sort();
alert( arr );  // 1, 15, 2
по умолчанию sort сортирует, преобразуя элементы к строке.
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
Если эту функцию не указать, то элементы сортируются как строки.
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a < b) return -1;
}
var arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15
Алгоритм сортировки, встроенный в JavaScript, будет передавать ей для сравнения элементы массива. Она должна возвращать:
Положительное значение, если a > b,
Отрицательное значение, если a < b,
Если равны – можно 0, но вообще – не важно, что возвращать, если их взаимный порядок не имеет значения.

Сравнение compareNumeric в одну строку
function compareNumeric(a, b) {
  return a - b;
}
Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, отрицательное, если наоборот, и 0, если числа равны.

Метод arr.reverse() меняет порядок элементов в массиве на обратный.

Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
var arr = [1, 2];
var newArr = arr.concat(3, 4);
alert( newArr ); // 1,2,3,4
Если аргумент concat – массив, то concat добавляет элементы из него.
var arr = [1, 2];
var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)
alert( newArr ); // 1,2,3,4,5

Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.

Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.
Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.
Для поиска используется строгое сравнение ===.

ar arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
Метод «arr.lastIndexOf(searchElement[, fromIndex])» ищет справа-налево: с конца массива или с номера fromIndex, если он указан

Ранее мы говорили о том, что свойства объекта можно перебрать в цикле for..in.
Если мы хотим работать с ними в виде массива, то к нашим услугам – замечательный метод Object.keys(obj).
var user = {
  name: "Петя",
  age: 30
}
var keys = Object.keys(user);
alert( keys ); // name, age ---массив!

__________________________________________Массив: перебирающие методы__________________________________
forEach Метод «arr.forEach(callback[, thisArg])» используется для перебора массива.
Он для каждого элемента массива вызывает функцию callback.
Этой функции он передаёт три параметра callback(item, i, arr):
item – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.
Например:
var arr = ["Яблоко", "Апельсин", "Груша"];
arr.forEach(function(item, i, arr) {
  alert( i + ": " + item + " (массив:" + arr + ")" );
});
Метод forEach ничего не возвращает, его используют только для перебора, как более «элегантный» вариант, чем обычный цикл for.

filter Метод «arr.filter(callback[, thisArg])» используется для фильтрации массива через функцию.
Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.
Например:
var arr = [1, -1, 2, -2, 3];
var positiveArr = arr.filter(function(number) {
  return number > 0;
});
alert( positiveArr ); // 1,2,3

map Метод «arr.map(callback[, thisArg])» используется для трансформации массива.
Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.
Например:
var names = ['HTML', 'CSS', 'JavaScript'];
var nameLengths = names.map(function(name) {
  return name.length;
});
// получили массив с длинами
alert( nameLengths ); // 4,3,10

every/some Эти методы используются для проверки массива.
Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.
Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.
var arr = [1, -1, 2, -2, 3];
function isPositive(number) {
  return number > 0;
}
alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) ); // true, есть хоть одно положительное

reduce/reduceRight
Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Чуть далее мы разберём пример для вычисления суммы.
Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.
Аргументы функции callback(previousValue, currentItem, index, arr):
previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
index – номер текущего элемента.
arr – обрабатываемый массив.
Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.
Проще всего понять работу метода reduce на примере.
Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.
Вот решение в одну строку:
 var arr = [1, 2, 3, 4, 5]
// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current;
}, 0);
alert( result ); // 15
Разберём, что в нём происходит.
При первом запуске sum – исходное значение, с которого начинаются вычисления, равно нулю (второй аргумент reduce).
Сначала анонимная функция вызывается с этим начальным значением и первым элементом массива, результат запоминается и передаётся в следующий вызов, уже со вторым аргументом массива, затем новое значение участвует в вычислениях с третьим аргументом и так далее.
В виде таблицы где каждая строка – вызов функции на очередном элементе массива:
sum	current	результат
первый вызов	0	1	1
второй вызов	1	2	3
третий вызов	3	3	6
четвёртый вызов	6	4	10
пятый вызов	10	5	15
Как видно, результат предыдущего вызова передаётся в первый аргумент следующего.
Кстати, полный набор аргументов функции для reduce включает в себя function(sum, current, i, array), то есть номер текущего вызова i и весь массив arr, но здесь в них нет нужды.
Посмотрим, что будет, если не указать initialValue в вызове arr.reduce:
 var arr = [1, 2, 3, 4, 5]
// убрали 0 в конце
var result = arr.reduce(function(sum, current) {
  return sum + current
});
alert( result ); // 15
Результат – точно такой же! Это потому, что при отсутствии initialValue в качестве первого значения берётся первый элемент массива, а перебор стартует со второго.
Таблица вычислений будет такая же, за вычетом первой строки.
Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.

______________________________________Псевдомассив аргументов "arguments"_______________________________
Как получить значения аргументов, которых нет в списке параметров?
Доступ к ним осуществляется через «псевдо-массив» arguments.
Он содержит список аргументов по номерам: arguments[0], arguments[1]…, а также свойство length.
Например, выведем список всех аргументов:
 function sayHi() {
  for (var i = 0; i < arguments.length; i++) {
    alert( "Привет, " + arguments[i] );
  }
}
sayHi("Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'
Все параметры находятся в arguments, даже если они есть в списке. Код выше сработал бы также, будь функция объявлена sayHi(a,b,c).
Частая ошибка новичков – попытка применить методы Array к arguments. Это невозможно:
 function sayHi() {
  var a = arguments.shift(); // ошибка! нет такого метода!
}
sayHi(1);
Дело в том, что arguments – это не массив Array.
В действительности, это обычный объект, просто ключи числовые и есть length. На этом сходство заканчивается. Никаких особых методов у него нет, и методы массивов он тоже не поддерживает.
Иногда встаёт задача – скопировать в существующий объект свойства из одного или нескольких других.

Напишем для этого функцию copy. Она будет работать с любым числом аргументов, благодаря использованию arguments.
Синтаксис:
copy(dst, src1, src2…)
Копирует свойства из объектов src1, src2,... в объект dst. Возвращает получившийся объект.
Использование:
Для объединения нескольких объектов в один:
var vasya = {
  age: 21,
  name: 'Вася',
  surname: 'Петров'
};
var user = {
  isAdmin: false,
  isEmailConfirmed: true
};
var student = {
  university: 'My university'
};
// добавить к vasya свойства из user и student
copy(vasya, user, student);
alert( vasya.isAdmin ); // false
alert( vasya.university ); // My university

Аргументы по умолчанию через ||
Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными undefined.
Зачастую в случае отсутствия аргумента мы хотим присвоить ему некоторое «стандартное» значение или, иначе говоря, значение «по умолчанию». Это можно удобно сделать при помощи оператора логическое ИЛИ ||.
Например, функция showWarning, описанная ниже, должна показывать предупреждение. Для этого она принимает ширину width, высоту height, заголовок title и содержимое contents, но большая часть этих аргументов необязательна:
function showWarning(width, height, title, contents) {
  width = width || 200; // если не указана width, то width = 200
  height = height || 100; // если нет height, то height = 100
  title = title || "Предупреждение";
}

Аргументы по умолчанию через ||
Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными undefined.
Зачастую в случае отсутствия аргумента мы хотим присвоить ему некоторое «стандартное» значение или, иначе говоря, значение «по умолчанию». Это можно удобно сделать при помощи оператора логическое ИЛИ ||.
Например, функция showWarning, описанная ниже, должна показывать предупреждение. Для этого она принимает ширину width, высоту height, заголовок title и содержимое contents, но большая часть этих аргументов необязательна:
function showWarning(width, height, title, contents) {
  width = width || 200; // если не указана width, то width = 200
  height = height || 100; // если нет height, то height = 100
  title = title || "Предупреждение";
}

_______________________________________________Дата и Время_____________________________________________

Для работы с датой и временем в JavaScript используются объекты Date.
Для создания нового объекта типа Date используется один из синтаксисов:
new Date()
Создает объект Date с текущей датой и временем:
var now = new Date();
alert( now );

new Date(milliseconds)
Создает объект Date, значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0.

new Date(datestring)
Если единственный аргумент – строка, используется вызов Date.parse (см. далее) для чтения даты из неё.

new Date(year, month, date, hours, minutes, seconds, ms)
Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице.
Заметим:
Год year должен быть из 4 цифр.
Отсчет месяцев month начинается с нуля 0.

Для доступа к компонентам даты-времени объекта Date используются следующие методы:
new Date().getFullYear() Получить год (из 4 цифр)
getMonth()Получить месяц, от 0 до 11.
getDate()Получить число месяца, от 1 до 31.
getHours(), getMinutes(), getSeconds(), getMilliseconds()Получить соответствующие компоненты.
getDay() Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота).
Все методы, указанные выше, возвращают результат для местной временной зоны.
Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC): getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после "get" вставляется "UTC".
getTime() Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, то есть того же вида, который используется в конструкторе new Date(milliseconds).
getTimezoneOffset() Возвращает разницу между местным и UTC-временем, в минутах.

Следующие методы позволяют устанавливать компоненты даты и времени:
setFullYear(year [, month, date])
setMonth(month [, date])
setDate(date)
setHours(hour [, min, sec, ms])
setMinutes(min [, sec, ms])
setSeconds(sec [, ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)

Более точное время с performance.now()
В современных браузерах (кроме IE9-) вызов performance.now() возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее – с момента выгрузки предыдущей страницы из памяти.

console.time(метка) и console.timeEnd(метка)
Для измерения с одновременным выводом результатов в консоли есть методы:
console.time(метка) – включить внутренний хронометр браузера с меткой.
console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.

методы для форматирования дат.
Это делается вызовом date.toLocaleString(локаль, опции), в котором можно задать много настроек. Он позволяет указать, какие параметры даты нужно вывести, и ряд настроек вывода, после чего интерпретатор сам сформирует строку.

Методы вывода без локализации:
toString(), toDateString(), toTimeString() Возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему – читаемость человеком. Метод toString возвращает дату целиком, toDateString() и toTimeString() – только дату и время соответственно.

Все современные браузеры, включая IE9+, понимают даты в упрощённом формате ISO 8601 Extended.
Этот формат выглядит так: YYYY-MM-DDTHH:mm:ss.sssZ, где:
YYYY-MM-DD – дата в формате год-месяц-день.
Обычный символ T используется как разделитель.
HH:mm:ss.sss – время: часы-минуты-секунды-миллисекунды.
Часть 'Z' обозначает временную зону – в формате +-hh:mm, либо символ Z, обозначающий UTC. По стандарту её можно не указывать, тогда UTC, но в Safari с этим ошибка, так что лучше указывать всегда.
Также возможны укороченные варианты, например YYYY-MM-DD или YYYY-MM или даже только YYYY.
Метод Date.parse(str) разбирает строку str в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, Date.parse возвращает NaN.

Метод Date.now() возвращает дату сразу в виде миллисекунд.
Технически, он аналогичен вызову +new Date(), но в отличие от него не создаёт промежуточный объект даты, а поэтому – во много раз быстрее.
Его использование особенно рекомендуется там, где производительность при работе с датами критична. Обычно это не на веб-страницах, а, к примеру, в разработке игр на JavaScript.

_________________________________________________Глобальный объект______________________________________
Глобальными называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции function, то они – «глобальные»
В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» (global object).
В браузере этот объект явно доступен под именем window. Объект window одновременно является глобальным объектом и содержит ряд свойств и методов для работы с окном браузера, но нас здесь интересует только его роль как глобального объекта.
В других окружениях, например Node.JS, глобальный объект может быть недоступен в явном виде, но суть происходящего от этого не изменяется, поэтому далее для обозначения глобального объекта мы будем использовать "window".
Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.
Например:
 var a = 5; // объявление var создаёт свойство window.a
alert( window.a ); // 5
Функции, объявленные как Function Declaration, создаются полностью и готовы к использованию.
Переменные объявлены, но равны undefined. Присваивания выполнятся позже, когда выполнение дойдет до них.

___________________________________________Замыкания, функции изнутри___________________________________

Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.
При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения.
В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа.
Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window.
Такой порядок поиска возможен благодаря тому, что ссылка на внешний объект переменных хранится в специальном внутреннем свойстве функции, которое называется [[Scope]]. Это свойство закрыто от прямого доступа, но знание о нём очень важно для понимания того, как работает JavaScript
При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.

Каждая функция при создании получает ссылку [[Scope]] на объект с переменными, в контексте которого была создана.
При запуске функции создаётся новый объект с переменными LexicalEnvironment. Он получает ссылку на внешний объект переменных из [[Scope]].
При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.

Значение переменной из внешней области берётся всегда текущее. Оно может быть уже не то, что было на момент создания функции.

Переменную во внешней области видимости можно не только читать, но и изменять.

Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней
function f() {}
f.test = 5;
alert( f.test );
Свойства функции не стоит путать с переменными и параметрами.
А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».
Если хочется привязать значение к функции, то можно им воспользоваться вместо внешних переменных.
В качестве демонстрации, перепишем пример со счётчиком:

function makeCounter() {
  function counter() {
    return counter.currentCount++;
  };
  counter.currentCount = 1;

  return counter;
}

var counter = makeCounter();
alert( counter() ); // 1
alert( counter() ); // 2


















