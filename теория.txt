В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
typeof null // "object"– это официально признанная ошибка в языке

undefined «значение не присвоено»
Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined

Операнд – то, к чему применяется оператор.Другое название: «аргумент оператора»

Унарным называется оператор, который применяется к одному выражению.

Бинарным называется оператор, который применяется к двум операндам. 

Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!
Это приведение к строке – особенность исключительно бинарного оператора "+".
Остальные арифметические операторы работают только с числами и всегда приводят аргументы к числу.

Инкремент ++ увеличивает на 1
Декремент -- уменьшает на 1

i++ (называется «постфиксная форма») или ++i («префиксная форма»).

Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.
Если результат оператора не используется, а нужно только увеличить/уменьшить переменную – без разницы, какую форму использовать
Если хочется тут же использовать результат, то нужна префиксная форма

var n = 2;
n += 5; // теперь n=7 (работает как n = n + 5)

alert( 0 == false ); // true
alert( '' == false ); // true

Значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
При преобразовании в число null становится 0, а undefined становится NaN.
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true

Значение undefined вообще нельзя сравнивать

Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.

confirm выводит окно с вопросом question с двумя кнопками: OK и CANCEL.

Результатом будет true при нажатии OK и false – при CANCEL(Esc)

В логическом контексте:
Число 0, пустая строка "", null и undefined, а также NaN являются false,
Остальные значения – true.

|| запинается на «правде»,
&& запинается на «лжи».

Численное преобразование:
undefined	NaN
null	0
true / false	1 / 0
Строка	Пробельные символы по краям обрезаются.
Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.

Function Declaration – функция, объявленная в основном потоке кода.
Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.
Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.


Function                         Declaration	                  Function Expression
Время создания	    До выполнения первой строчки кода.         	Когда управление достигает строки с функцией.
Можно вызвать до объявления	Да (т.к. создаётся заранее)	          Нет
Условное объявление в if	Не работает	                        Работает

В теле функции могут быть вызываны другие функции для выполнения подзадач.
Частный случай подвызова – когда функция вызывает сама себя. Это называется рекурсией.
Рекурсия используется для ситуаций, когда выполнение одной сложной задачи можно представить как некое действие в совокупности с решением той же задачи в более простом варианте.

Watch Expressions – показывает текущие значения любых выражений.

Можно раскрыть эту вкладку, нажать мышью + на ней и ввести любое выражение. Отладчик будет отображать его значение на текущий момент, автоматически перевычисляя его при проходе по коду.

Call Stack – стек вызовов, все вложенные вызовы, которые привели к текущему месту кода.
На текущий момент видно, отладчик находится в функции pow (pow.js, строка 6), вызванной из анонимного кода (index.html, строка 13).
Scope Variables – переменные.
На текущий момент строка 6 ещё не выполнилась, поэтому result равен undefined.
В Local показываются переменные функции: объявленные через var и параметры. Вы также можете там видеть ключевое слово this, если вы не знаете, что это такое – ничего страшного, мы это обсудим позже, в следующих главах учебника.
В Global – глобальные переменные и функции.

BDD – поведенческие тесты кода Behavior Driven Development. Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.

Вот самые востребованные assert-проверки, встроенные в Chai:

assert(value) – проверяет что value является true в логическом контексте.
assert.equal(value1, value2) – проверяет равенство value1 == value2.
assert.strictEqual(value1, value2) – проверяет строгое равенство value1 === value2.
assert.notEqual, assert.notStrictEqual – проверки, обратные двум предыдущим.
assert.isTrue(value) – проверяет, что value === true
assert.isFalse(value) – проверяет, что value === false
…более полный список – в документации http://chaijs.com/api/assert/

свойство length, содержащее длину
Также у строк есть метод toUpperCase(), который возвращает строку в верхнем регистре
Метод – это встроенная команда («функция», мы поговорим о них позже), которую нужно вызвать для получения значения.
Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки

Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity

