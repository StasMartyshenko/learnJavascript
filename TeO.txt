___________________________________________________Числа!______________________________________________
length содержащее длину

num.toFixed(n) метод округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки.

isNaN(n) функция которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.

isFinite(n) функция преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity

parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat – дробноe

toString() метод возвращает строку, представляющую объект.

Math.floor Округляет вниз
Math.ceil Округляет вверх
Math.round Округляет до ближайшего целого
Math.acos(x)Возвращает арккосинус x (в радианах)
Math.asin(x)Возвращает арксинус x (в радианах)
Math.atan(x)Возвращает арктангенс x (в радианах)
Math.atan2(y, x)Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)Вычисляет синус x
Math.cos(x)Вычисляет косинус x
Math.tan(x)Возвращает тангенс xФункции общего назначения
Math.sqrt(x)Возвращает квадратный корень из x.
Math.log(x)Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)Возвращает абсолютное значение числа
Math.exp(x)Возвращает ex, где e – основание натуральных логарифмов.
Math.max(a, b, c...)Возвращает наибольший из списка аргументов
Math.min(a, b, c...)Возвращает наименьший из списка аргументов
Math.random()Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.

_________________________________________________Строки_________________________________________________
charAt(позиция) чтобы получить символ var str = "jQuery"; alert( str.charAt(0) ); // "j" или str[0]
Разница между этим способом и charAt заключается в том, что если символа нет – charAt выдает пустую строку, а скобки – undefined

toLowerCase() и toUpperCase() методы меняют регистр строки на нижний/верхний

indexOf(подстрока[, начальная_позиция]) для поиска подстроки есть метод Он возвращает позицию, на которой находится подстрока или -1, если ничего не найдено.var str = "Widget with id"; alert( str.indexOf("id") ); // 1

substring(start, end) метод возвращает подстроку с позиции start до, но не включая end.Если аргумент end отсутствует, то идет до конца строки Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки Кроме того, если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end

substr(start [, length]) первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов. Если второго аргумента нет – подразумевается «до конца строки».

slice(start [, end]) возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring. Отрицательные значения отсчитываются от конца строки Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами

String.fromCharCode(code) озвращает символ по коду code: alert( String.fromCharCode(1072) ); // 'а'

str.charCodeAt(pos) возвращает код символа на позиции pos. Отсчет позиции начинается с нуля. alert( "абрикос".charCodeAt(0) ); // 1072, код 'а'

_______________________________________Объекты как ассоциативные массивы________________________________
Ассоциативный массив – структура данных, в которой можно хранить любые данные в формате ключ-значение.
Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства (иногда говорят «по ключу»).

var person = {};
person.name = 'Вася';
person.age = 25;
delete person.name;
console.log(person.name);
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:
person['OS'] = 'Ubuntu';

Объект — это набор свойств, и каждое свойство состоит из имени и значения, ассоциированного с этим именем. Значением свойства может быть функция, которую можно назвать методом объекта

Такой синтаксис называется литеральным
var menuSetup = {
  width: 300,
  height: 200,
  title: "Menu"
};

____________________________________________Объекты: перебор свойств____________________________________
Для перебора всех свойств из объекта используется цикл по свойствам for..in. Эта синтаксическая конструкция 
var obj = {
  menu: 'Cesar',
  time: '18.00',
  day: 'monday'
};
for (dec in obj) {
    console.log(dec + ':' + obj[dec]);
}

____________________________________Массивы с числовыми индексами_______________________________________
Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные методы для удобного манипулирования такой коллекцией.

Элементы нумеруются, начиная с нуля.
var fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits[0] ); // Яблоко

pop удаляет последний элемент из массива и возвращает его fruits.pop()

push добавляет элемент в конец массива fruits.push("Груша"); или так arr[arr.length] = 'xnjsdfs'; /могут добавлять сразу по несколько элементов

shift Удаляет из массива первый элемент и возвращает его fruits.shift()

unshift Добавляет элемент в начало массива /могут добавлять сразу по несколько элементов

Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.

length – не количество элементов массива, а последний индекс + 1 Так уж оно устроено.

Существует еще один синтаксис для создания массива:
var arr = new Array("Яблоко", "Груша", "и т.п.");
если у него один аргумент-число new Array(число), то он создает массив без элементов, но с заданной длиной.

_______________________________________________Массивы: методы__________________________________________
split(s), метод который позволяет превратить строку в массив, разбив ее по разделителю s. В примере ниже таким разделителем является строка из запятой и пробела.
var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', ');
for (var i = 0; i < arr.length; i++) {
  alert( 'Вам сообщение ' + arr[i] );
}
У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен

arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.
var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');
alert( str ); // Маша;Петя;Марина;Василий

delete arr[1]; // значение с индексом 1 удалено
элемент удален из массива, но не так, как нам этого хочется. Образовалась «дырка».
оператор delete удаляет пару «ключ-значение». Это – все, что он делает. 

splice – это метод универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.
arr.splice(index[, deleteCount, elem1, ..., elemN])

arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент

// удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем")

// удалить 2 первых элемента
var removed = arr.splice(0, 2);
alert( removed ); // "Я", "сейчас" <-- Здесь видно, что splice возвращает массив из удаленных элементов

Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0: arr.splice(2, 0, "сложный", "язык");
Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.
var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
alert( arr2 ); // надо, учить
Если не указать end – копирование будет до конца массива
Можно использовать отрицательные индексы, они отсчитываются с конца
Если вообще не указать аргументов – скопируется весь массив

sort() метод сортирует массив на месте.
var arr = [ 1, 2, 15 ];
arr.sort();
alert( arr );  // 1, 15, 2
по умолчанию sort сортирует, преобразуя элементы к строке.
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнивать их.
Если эту функцию не указать, то элементы сортируются как строки.
function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a < b) return -1;
}
var arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15
Алгоритм сортировки, встроенный в JavaScript, будет передавать ей для сравнения элементы массива. Она должна возвращать:
Положительное значение, если a > b,
Отрицательное значение, если a < b,
Если равны – можно 0, но вообще – не важно, что возвращать, если их взаимный порядок не имеет значения.
Сравнение compareNumeric в одну строку
function compareNumeric(a, b) {
  return a - b;
}
Эта функция вполне подходит для sort, так как возвращает положительное число, если a > b, отрицательное, если наоборот, и 0, если числа равны.

arr.reverse() метод меняет порядок элементов в массиве на обратный.

arr.concat(value1, value2, … valueN) метод создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN.
var arr = [1, 2];
var newArr = arr.concat(3, 4);
alert( newArr ); // 1,2,3,4
Если аргумент concat – массив, то concat добавляет элементы из него.
var arr = [1, 2];
var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)
alert( newArr ); // 1,2,3,4,5

arr.indexOf(searchElement[, fromIndex]) метод возвращает номер элемента searchElement в массиве arr или -1, если его нет.Поиск начинается с номера fromIndex, если он указан. Если нет – с начала массива.
Для поиска используется строгое сравнение ===.
ar arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

arr.lastIndexOf(searchElement[, fromIndex]) метод ищет справа-налево: с конца массива или с номера fromIndex, если он указан

_________________________________________Массив: перебирающие методы____________________________________
методы
forEach – для перебора массива.
filter – для фильтрации массива.
every/some – для проверки массива.
map – для трансформации массива в массив.
reduce/reduceRight – для прохода по массиву с вычислением значения

______________________________________________Псевдомассив аргументов "arguments"______________________
Полный список аргументов, с которыми вызвана функция, доступен через arguments.
Это псевдомассив, то есть объект, который похож на массив, в нём есть нумерованные свойства и length, но методов массива у него нет.
В старом стандарте было свойство arguments.callee со ссылкой на текущую функцию, а также свойство arguments.callee.caller, содержащее ссылку на функцию, которая вызвала данную. Эти свойства устарели, при use strict обращение к ним приведёт к ошибке.
Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не false, удобен оператор ||.
В тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию, вместо работы с arguments организуют передачу данных через объект, который как правило называют options.
Возможен и гибридный подход, при котором первый аргумент обязателен, а второй – options, который содержит всевозможные дополнительные параметры:
function showMessage(text, options) {
  // показать сообщение text, настройки показа указаны в options
}

_______________________________________________Дата и Время_____________________________________________
Дата и время представлены в JavaScript одним объектом: Date. Создать «только время» при этом нельзя, оно должно быть с датой. Список методов Date вы можете найти в справочнике Date или выше.
Отсчёт месяцев начинается с нуля.
Отсчёт дней недели (для getDay()) тоже начинается с нуля (и это воскресенье).
Объект Date удобен тем, что автокорректируется. Благодаря этому легко сдвигать даты.
При преобразовании к числу объект Date даёт количество миллисекунд, прошедших с 1 января 1970 UTC. Побочное следствие – даты можно вычитать, результатом будет разница в миллисекундах.
Для получения текущей даты в миллисекундах лучше использовать Date.now(), чтобы не создавать лишний объект Date (кроме IE8-)
Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее.

